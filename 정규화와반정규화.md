# 정규화와 반정규화

## 함수 종속성
어떤 테이블의 속성 A, B에 대해 A값에 의해 B값이 유일하게 정해지는 관계를 의미
  - B는 A에 함수 종속이다
  - A->B
  - A 는 결정자(Determinant), B는 종속자(Dependant)

### 함수 종속성의 분류
1. 완전 함수 종속
  - 기본키를 구성하는 모든 속성에 종속되는 경우
2. 부분 함수 종속
  - 기본키를 구성하는 속성의 일부에 종속되거나 기본키가 아닌 다른 속성에 종속되는 경우
3. 이행 함수 종속
  - A->B, B->C 종속 관계가 있을 때 A->C 가 성립하는 경우
  - 즉, B는 A에 함수 종속하고, C는 B에 함수 종속하면 C는 A에 함수 종속한다는 것

### 함수 종속성 예시
학생 테이블 [학번 PK, 이름, 학년, 과목코드 PK, 성적] 이 있을 때
- 이름과 학년은 학번만 알아도 유일하게 결정이 가능하다 = 부분 함수 종속
- 성적은 학번과 과목코드 모두 알아야 결정이 가능하다 = 완전 함수 종속


## 정규화
* 정규형 : 정규화로 도출된 데이터 모델이 갖춰야할 특성
- 데이터의 일관성, 최소한의 데이터 중복, 최소한의 데이터 유연성을 위한 방법
- 데이터를 분해하는 과정 -> 이상 현상을 제거
  - 이상 현상 (Anomaly) : 테이블 내 데이터들이 불필요하게 중복되어 테이블을 조작할 때 발생하는 데이터의 불일치 현상
    - 삽입 이상
    - 삭제 이상
    - 갱신 이상
- 정규화된 모델은 테이블이 분해된다.
- 불필요한 데이터를 입력하지 않아도 되기 때문에 중복 데이터가 제거된다.

### 정규화로 인한 성능 향상
- 입력/수정/삭제 성능은 항상 향상
- 유연성이 증가 - High Cohesion & Loose Coupling
- 재활용 가능성 증가 -> 개념이 세분화
- 데이터 중복 최소화


### 정규화의 절차
#### 제 1정규화
- 모든 속성은 반드시 하나의 값을 가져야 한다. -> 원자성
- 반복 형태가 있어선 안된다.
- 속성의 중복값을 제거 (다중 속성값 분리)
- M:N 관계를 1:M으로 변환
```
ex. 고객 연락처가 2개라면, 고객 테이블에 쉼표로 나열하는 것이 아니라 고객 연락처 테이블을 생성하여 관리
ex. 주문에 대한 상세 상품 내역 안, 상품1, 상품2, ... 컬럼이 아닌, 주문 상세 테이블을 생성하여 관리
```

#### 제 2정규화
- 모든 속성은 반드시 기본키 전부에 종속되어야 한다.
- 기본키 일부에만 종속되어선 안됨
- 함수의 부분 종속을 분리
- 기본키에 의해 함수적 종속성을 가지고 있지 않은 것들을 분리
- 기본키가 2개 이상의 속성으로 이루어진 경우, 부분 함수 종속성을 제거하여 완전 함수 종속을 만족하도록 테이블을 분해하는 것
- 부분 함수 종속성이란 기본키가 2개 이상인 칼럼으로 이루어진 경우에만 발생 (기본키가 1개면 스킵)
```
ex. 주문 테이블 [주문번호 PK / 상품번호 PK / 상품명 ] 에서 상품명은 주식별자인 주문번호+상품번호에 종속되는 것이 아닌, 상품번호에 의해서만 함수 종속성을 가지고 있다.
이때, 상품명을 변경하고자하면 주문상세에서 모든 상품명에 대한 데이터를 변경해줘야 한다. 그렇지 않으면 갱신 이상이 발생할 수 있으므로 상품 테이블을 별도로 만들어서 상품번호-상품명을 같이 관리해준다.
```

#### 제 3정규화
- 기본키가 아닌 모든 속성 간 서로 종속될 수 없다. (일반 속성의 종속성을 제거)
- 모든 속성들이 기본키에 이행적 함수 종속이 아니어야 한다.
  - 이행적 종속은 A->B, B->C 가 성립할 때 A->C가 성립하는 것으로, 말그대로 종속이 두 번 맺어진 관계이다.
- 서로 종속 관계에 있는 일반 속성을 분리
```
ex. 주문 테이블 [ 주문번호 PK / 고객번호 / 고객명 ] 에서 주문 번호-고객번호가 종속관계이고, 고객번호-고객명이 종속관계라면 주문번호-고객명은 이행 종속이라고 한다.
그렇다면 고객 테이블을 생성하여 고객번호-고객명 / 주문번호-고객번호로 테이블을 나눠서 관리하여 제 3정규화를 수행한다.
```

#### BCNF 정규형 (Boyce Codd Normal Form)
- 복잡한 식별자 관계에 의해 발생하는 문제를 해결하기 위해 제 3정규형을 보완
- 모든 결정자가 후보키가 되도록 테이블을 분해, 후보키가 아닌 것들을 제외 및 분리
- 후보키가 기본키 속성 중 일부에 함수적 종속일 때 다수의 주식별자를 분리

#### 제 4정규화
- 여러 칼럼들이 하나의 칼럼을 종속하는 경우, 분해아여 다중값 종속성을 제거
- 다치 종속성을 제거

#### 제 5정규화
- 조인에 의해 종속성이 발생되는 경우 분해


### 정규화의 문제점
정규화는 데이터 조회 시 조인을 유발하므로 CPU와 메모리를 많이 사용하게 된다.
-> 조인으로 인하여 성능이 저하되는 문제를 반정규화로 해결할 수 있다, 다만 반정규화는 데이터를 중복시키기에 다른 문제점을 야기한다.


## 반정규화
- 데이터베이스트의 성능 향상을 위해 데이터 중복을 허용하고, 조인을 줄이는 데이터베이스 성능 향상 방법
- 데이터 무결성이 깨질 수 있는 위험을 감수하고 조회 속도를 향상시키지만 데이터 모델의 유연성은 낮아진다.

### 반정규화를 수행하는 이유
- 정규화에 충실하여 종속성, 활용성은 향상되었지만 수행속도가 느려진 경우
- 다량의 범위, 특정 범위의 데이터를 자주 처리하는 경우
- 요약, 집계 정보가 자주 요구되는 경우
```
조인을 거치는 쿼리에서 조인된 테이블의 모든 데이터를 읽고 가져오기에
데이터가 많아질수록 성능이 나빠진다.
그래서 성능향상을 위해 구분 칼럼을 속성으로 추가하여, 조인 없이 SQL을 수행

ex. 주문 테이블 [ 주문번호 / 고객번호 / 주문상태 ]와 결제 테이블 [ 결제번호 / 주문번호 / 결제수단코드 ]에서 고객번호를 알기위해선 주문-결제 테이블을 조인하지 않고, 결제 테이블에 고객번호 칼럼을 추가하여 조인없이 수행
```

### 반정규화 절차
1. 대상 조사 및 검토 : 데이터 처리 범위, 통계성 등을 확인하여 반정규화 대상을 조사
   - 범위 처리 빈도수 조사
   - 대량의 범위 처리 조사
   - 통계성 프로세스 조사
   - 테이블 조인 개수  
2. 다른 방법 검토 : 반정규화를 수행하기 전 다른 방법이 있는지 검토
    - 뷰 테이블
    - 클러스터링 적용
    - 인덱스의 조정
    - 응용 애플리케이션
3. 반정규화 수행 : 테이블, 속성, 관계 등을 반정규화한다.
* PK 순서를 결정하는 기준은 인덱스 정렬 구조와 유사
  인덱스의 특징은 여러 개의 속성이 하나의 인덱스로 구성되어 있을 때, 앞에 위치한 속성의 값이 비교자로 있어야 인덱스가 좋은 효율을 나타낼 수 있다. 특히나 '=' > 'Between' > '<, >' 순으로 효율이 좋다.

### 반정규화의 성능저하
주문 테이블에 송장번호까지 넣으면 배송 테이블을 조인하지 않아도 되므로 조회성능이 빨라진다. 다만 송장번호 갱신 로직이 추가되어 저하될 수 있다.


### 반정규화 기법
- 컬럼의 반정규화
    - 계산된 칼럼(파생칼럼) 추가
    - 중복 칼럼 추가
    - 이력 테이블 컬럼 추가
    - PK에 의한 칼럼 추가
    - 응용 시스템 오작동을 위한 칼럼 추가
- 테이블의 반정규화
  - 테이블 병함
    - 1:1 관계 테이블 병합
    - 1:M 관계 테이블 병합
    - 슈퍼/서브 타입 테이블 병합 : 슈퍼타입+서브타입에 대해 발생하는 트랜잭션에 대해서 슈퍼타입+서브타입 테이블로 구성
      - 개별로 발생하는 트랜잭션에 대해 개별 테이블로 구성
      - 전체를 하나로 묶어 트랜잭션이 발생할 때 하나의 테이블로 구성
  - 하나의 테이블을 두 개 이상의 테이블로 분할 (수직/수평분할)
  - 테이블 추가
    - 중복 테이블 추가
    - 통계 테이블 추가
    - 이력 테이블 추가
    - 부분 테이블 추가 : PK의 성격에 따라 테이블 분리 -> 파티셔닝 기법
  - 테이블 수평 분할
    - 하나의 테이블에 있는 값을 기준으로 테이블을 분할
* 파티셔닝 : 하나의 태이블에 많은 양의 데이터가 저장되면 인덱스를 추가하고 테이블을 몇 개로 쪼개도 성능이 저하되는 경우가 있다. 이때 논리적으로 하나의 테이블이지만 물리적으로 여러 개의 테이블로 분리하여 데이터 성능을 향상시키는 기법


### 반정규화 대상에 대한 다른 방법으로 처리
- 지나치게 많은 Join이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 View 를 사용하여 이를 해결
- 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우 클러스터링을 적용하거나 인덱스를 조정함으로써 성능을 향상시킬 수 있음
  - 클러스터링 (Clustering) : 디스크로부터 데이터를 읽어오는 시간을 줄이기 위해 조인이나 자주 사용되는 테이블의 데이터를 디스크의 같은 물리적인 위치에 정렬해서 저장시키는 방법
  - 클러스터링 인덱스라는 것은 인덱스 정보를 저장할 때, 물리적으로 정렬해서 저장하는 방법으로 조회 시 인접 블록을 연속적으로 읽기 때문에 성능이 향상된다.
- 파티셔닝 기법 : 대량의 데이터는 PK의 성격에 따라 부분적인 테이블로 분리 가능
- 응용 애플리케이션에서 로직을 구사하는 방법을 변경하여 성능을 향상시킬 수 있음


### 반정규화 정리
1. 조회(Select) 성능을 향상시키지만 불필요한 입력(Insert), 갱신(Update), 삭제(Delete) 로직이 추가된다.
2. 데이터 불일치로 인한 정합성 문제뿐만 아니라 불필요한 트랜잭션으로 인한 성능 문제 야기
3. 조회 성능에서 미미한 이점을 얻고 불필요한 갱신으로 성능을 손해를 본다면 반정규화를 고려해봐야 한다.
4. 합당한 근거를 기반으로 반정규화는 꼭 필요할 때 적용해야함

