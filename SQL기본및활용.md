# SQL 기본 및 활용

## 트랜잭션
데이터베이스의 논리적 연산단위로서 밀접히 관련되어 분리될 수 없는 1개 이상의 데이터베이스 조작

### 트랜잭션의 특징
1. 원자성 : 트랜잭션에 정의된 연산들은 모두 성공적으로 실행되던지 아니면 전혀 실행되지 않은 상태로 남아 있어야 한다.
2. 일관성 : 트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안된다.
3. 고립성/독립성 : 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어선 안된다.
4. 지속성 : 트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장된다.

### 트랜잭션 정리
- 데이터의 변경을 발생시키는 DML 언어 수행 시 데이터의 무결성을 보장하는 것이 커밋과 롤백의 목적
- 커밋은 변경된 데이터를 테이블이 영구적으로 반영한다는 의미
- 롤백은 변경 사항을 취소하고 변경 이전의 데이터로 복구하라는 의미
- Savepoint 는 데이터 변경을 사전에 지정한 저장점까지만 롤백하라는 의미
- 트랜잭션은 대상이 되는 SQL문을 실행하면 자동으로 시작하고 커밋 또는 롤백을 실행한 시점에 종료된다.
- 항상 전체를 통합하여 분석 처리하는데 슈퍼-서브타입이 하나의 테이블로 통합되어 있으면 하나의 테이블에 집적된 데이터만 읽어 처리할 수 있기에 다른 형식에 비해 성능이 우수함



## 데이터 언어
데이터베이스를 정의하고 접근하기 위한 데이터베이스 관리 시스템과의 통신수단

### 데이터 언어와 SQL 명령어
1. As-Is : 비절차적 데이터 조작어(DML)은 사용자가 무슨 데이터를 원하는지만을 명세 - What
2. To-Be : 절차적 데이터 조작어는 어떻게 데이터를 접근해야하는지 명세 - How
   - PL/SQL(오라클), T-SQL(SQL Server)



## 데이터 언어의 사용 목적에 따른 분류
### DDL (Data Definition Language) 데이터 정의어
Creat, Alter, Drop, Rename ... <br/>
테이블과 같은 데이터 구조를 정의하는데 사용되는 명령어들로 그러한 구조를 생성하거나 변경하거나 삭제하거 이름을 바꾸는 데이터 구조와 관련된 명령어

#### Create
##### 테이블 생성 시 주의사항
- 테이블명은 객체를 의미할 수 있는 단수형
- 다른 테이블의 이름과 중복되지 않아야 한다
- 한 테이블 내 칼럼명이 중복되지 않아야 한다
- 데이터 표준화 관점에 의거하여 칼럼에 대해서 다른 테이블까지 고려하여 데이터베이스 내에서 일관성 있게 사용
- 칼럼 뒤 데이터 유형은 꼭 필요하다
- 테이블명과 칼럼명은 문자로 시작해야한다 (숫자X)
- 벤더에 사전에 정의한 예약어는 쓸 수 없다
- A-Z, a-z, 0-9, _, $, # 문자만 사용 가능

#### 제약조건
무결성을 지키기 위해 사용
#### 제약조건의 종류
1. 고유키 (Unique Key) : 중복되지 않는 키, Null 이 가능하나 행을 구별할 수 있어야 한다.
2. 기본키 (Primary Key) : 중복되지 않으면서 Null이 아닌 키 -> 하나의 테이블에 하나의 기본키
3. 외래키 (Foreign Key) : 기본키를 가져와서 쓰는 키, 테이블 간 관계를 정의하기 위해 기본키를 다른 테이블의 외래키로 복사
  -  참조 무결성 제약 조건 선택이 가능하다. -> 삭제하려고 하는 테이블이나 데이터가 외부 다른 테이블에서 참조되고 있다면 삭제가 불가능하게 제약
    - 참조 무결성 Delete/Modify Action
     1. Cascade : 마스터 삭제 시 자식도 삭제
     2. Restrict : 자식 테이블에 PK가 없는 경우만 마스터 삭제
     3. Set Null : 마스터 삭제 시 자식 필드 Null
     4. Set Default : 마스터 삭제 시 자식 해당 필드 Default 값으로 설정
     5. No Action : 참조 무결성을 위반하는 삭제/수정 액션을 취하지 않음
    - 참조 무결성 Insert Action
     1. Automatic : 마스터 테이블에 PK가 없는 경우 마스터 PK를 생성 후 자식 입력
     2. Set Null : 마스터 테이블에 PK가 없는 경우 자식 외부키를 Null 값으로 처리
     3. Set Default : 마스터 테이블에 PK가 없는 경우 자식 외부키를 지정된 기본값으로 입력
     4. Dependent : 마스터 테이블에 PK가 존재할 때만 자식 입력 허용
     5. No Action : 참조 무결성을 위반하는 입력 액션을 취하지 않음
  -  한 테이블에 여러 개 존재할 수 있다.
  -  외래키 값은 Null 을 가질 수 있다.
4. Not Null : 값이 Null 이 아닌 키
5. Check : 입력값이 조건에 맞는지 확인
   - 데이터베이스에서 데이터의 무결성을 유지하기 위해 테이블의 특정 컬럼에 설정하는 제약

#### Alter table 테이블명 (Alter/Add/Drop) ...
- Alter table 테이블명 Alter/Modify Column (컬럼명 데이터유형) ...
- Alter table 테이블명 Drop Column 삭제할컬럼명 ... : 불필요한 컬럼 삭제
- Alter table 테이블명 Add Column ...
- Alter table 테이블명 Rename Column ...

#### Rename 테이블명 To 바꿀테이블명

#### Truncate Table 테이블명
테이블의 데이터를 전부 삭제하고 사용하고 있던 공간을 반납
- 해당 테이블의 데이터가 모두 삭제되지만 테이블 자체가 지워지는 것이 아님, 즉 컬럼값은 남아있지만 튜플은 없는 상태이다.
- 해당 테이블에 생성되어 있던 인덱스도 함께 truncate
- Delete 보다 Truncate 가 좋아보이나 원하는 데이터만 골라 삭제가 불가능 하다.

#### Drop Table 테이블명
테이블 자체를 삭제하는 명령어
- 테이블 자체가 모두 지워지며, 해당 테이블에 생성되어 있던 인덱스도 삭제됨
- 테이블 자체가 사라지는 것이므로 데이터도 삭제되고, 사용하던 공간도 모두 반납한다.
- 테이블의 구조와 제약 조건 등도 사라진다.

```
    Drop      |     Truncate     |     Delete
------------------------------------------------
   DDL        |    DML or DDL    |      DML
------------------------------------------------
  Rollback X  |     Rollback X   |   Commit 이전 Rollback O       
------------------------------------------------
  Auto Commit |  Auto Commit     |  사용자 Commit
------------------------------------------------
테이블이 사용했던 |  테이블이 사용했던    |  데이터를 모두
Storage를 모두 |  Storage 중 최초   |  Delete 해도
Release       |  테이블 생성 시     | 사용했던 Storage는
              | 할당된 Storage만   | Release 되지 않음
              |  남기고 Release   |
------------------------------------------------
테이블 정의 자체를|  테이블을 최초 생성된  |  데이터만 삭제
   완전히 삭제   |  초기 상태로 만듦    |
------------------------------------------------
```

#### 삭제 데이터에 대한 로그를 남기려면
테이블 삭제 시, 삭제 데이터에 대한 로그를 남기면서 사용 용도가 없다고 판단한 테이블의 데이터 삭제를 하기 위해서는 Delete from 테이블명 을 사용해준다. 위에 언급한 Truncate 와 Drop 은 로그를 남기지 않는다.


### DML(Data Manipulation Language) 데이터 조작어
- Select : 데이터베이스에 들어 있는 데이터를 조회하거나 검색하기 위한 명령어 - Retrieve 라고도 함
- Insert, Update, Delete ...<br/>
데이터베이스의 테이블에 들어있는 데이터에 변형을 가하는 종류의 명령어들을 의미

#### Select
- Distinct : 중복 요소 제거
- As : Alias, 별칭 지정

#### Update 테이블명 set 칼럼명=값

#### Insert into 테이블명 (컬럼명) values 값

#### Where 조건절
- 자신이 원하는 자료만 검색하기 위해 자료들에 대해 제한
- 연산자의 종류
  - 비교 연산자 : <, >, ^=, !=
  - SQL 연산자
    - Between A and B
    - In
    - Like '문자열'
    - Is Null
    - Not Between A and B
    - Not in
    - Is not null
  - 논리 연산자
    - And, Or, Not
  - 연산자 우선 순위
    1. 괄호
    2. 비교 연산자, SQL 연산자
    3. Not 연산자
    4. And
    5. Or

#### 집계함수
1. 여러 행들의 그룹이 모여서 그룹당 단 하나의 결과를 돌려주는 함수
2. Group by 절은 행들을 소 그룹화 한다.
3. Select, Having, Order by절에 사용할 수 있다.

#### 집계함수의 종류
1. Count(*) : Null 값을 포함한 행의 수 출력
2. Count(표현식) : Null 이 아닌 표현식 행의 수 출력
3. Sum() : Null 값 제외한 한계
4. Max() : Null 값 제외한 최대값 <-> Min()
5. Avg() : Null 값 제외한 평균
6. Stddeb() :Null 값 제외한 표준편차
7. Median() : Null 값 제외한 분산

#### Group by 절
1. 소그룹 별 기준 정한 후, Select절에 집계함수 사용
2. 집계함수는 Null값을 가진 행을 제외하고 수행
3. Having 절은 Group by 절의 기준 항목이나 소그룹의 집계 함수를 이용한 조건 표시
4. Having 절에서 제한 조건을 두어 조건을 만족하는 내용만 출력
5. Having 절은 Group by 앞/뒤에 위치 가능
6. 집계함수는 Where절에 올 수 없음. => Group by 보다 Where 이 먼저 수행 되므로

#### Having 절
1. Where 절에서는 집계 함수를 사용할 수 없다.
2. 집계된 결과 집합을 기준으로 특정 조건을 주고 싶은 경우 사용
3. 그룹을 나타내는 결과 집합의 행에 조건이 적용

#### 문자 유형 크기 비교 방법 (양쪽이 모두 Char 타입인 경우)
1. 길이가 서로 다르면 작은 쪽에 공백을 추가하여 길이를 같게 한다.
2. 서로 다른 문자가 나올 때까지 비교
3. 달라진 첫번째 값에 따라 크기를 결정 (AscII)
4. 공백의 수만 다르다면 같은 값으로 결정 -> 'ABC', 'ABC ' 같은 것으로 판단

#### 문자 유형 크기 비교 방법 (비교 연산자 중 한쪽이 Varchar인 경우)
1. 서로 다른 문자가 나올 때까지 비교
2. 길이가 서로 다르면 짧은 것이 끝날 때까지만 비교
3. 길이가 긴 것이 크다고 판단
4. 길이가 같고 다른 것이 없다면 같다고 판단
5. Varchar 는 공백도 문자로 판단 -> 'ABC', 'ABC ' 다른 것으로 판단

#### 문자 유형 크기 비교 방법 (상수값과 비교)
1. 상수쪽을 변수 타입과 동일하게 바꾸고 비교
2. 변수가 Char면 Char 유형 타입의 경우를 적용
3. 변수가 Varchar면 Varchar 유형을 적용

#### 그룹함수
- 소계/중계/합계/총합계 등을 구할 수 있음
- 하나의 SQL로 테이블을 한번만 읽어서 빠르게 원하는 리포트 작성 가능

#### 그룹함수의 종류
1. Rollup
- Subtotal(표현식 별 집계<->Grand Total)을 생성하기 위해 사용
- 그룹핑 컬럼 수가 n일 때, n+1만큼의 level의 Subtotal(표현식 별 집계) 결과값이 생성된다.
  ex. Rollup(부서, 업무, 성별) 인 경우
  - 부서별, 업무별, 성별별 집계
  - 부서별, 업무별 집계 - 모든 성별 포함
  - 부서별 집계 - 모든 성별, 모든 업무 포함
  - 전체 집계(Grand Total)
- 계층 구조이기에 순서가 바뀌면 수행 결과도 바뀌게 되므로 순서에도 주의
- Rollup(표현식1, 표헌식2, ...) 으로 Group by 뒤에 사용
2. Cube
- 다차원적인 소계를 계산
- 결합 가능한 모든 값에 대해 다차원 집계를 생성
- 그룹핑 칼럼의 수가 n일 때, 2의 n승 Subtotal 이 생성
  ex. Cube(부서, 성별, 업무)인 경우 3개의 컬럼이므로 2의 3승인 8개의 결과가 나온다.
- 시스템의 성능에 무리를 많이 준다.
3. Grouping sets
- Union all 을 사용한 SQL 과 같은 결과를 얻을 수 있다.
- 괄호를 묶은 집합 별로 집계를 구할 수 있다.

#### 윈도우 함수 = 분석함수
- 행과 행간의 관계에서 다양한 연산 처리를 할 수 있는 함수
- 중첩하여 호출할 수 없다

#### 윈도우 함수의 종류
1. 그룹 내 순위 함수 : Rank, Dense_rank, Row_number
2. 집계 함수 : Sum, Max, Min, Avg, Count
3. 그룹 내 행 순서 함수 : First_value, Last_value, Lag, Lead
4. 그룹 내 비율 함수 : Cume_dist, Percnet_rank, Ntile, Ratio_to_Report

#### 윈도우 함수 문법
```
Select 
  윈도우 함수 (인자) over ([Partition by 컬럼] [Order by 절] [Windowing절])
From 테이블명;
```
- 인자 : 함수에 따라 0~n개 인수 지정
- Partition by 절 : 전체 집합을 기준에 의해 소그룹으로 나눌 수 있다.
- Order by절 : 어떤 항목에 대해 순위를 지정할지 기술
- Windowing 절 : 함수의 대상이 되는 행 기준을 범위를 강력하게 지정
- Rows : 물리적인 결과 행의 수
- Range : 논리적인 값에 의한 범위


### DCL (Data Control Language) 데이터 제어어
Grant, Revoke ... <br/>
- 데이터베이스에 접근하고 객체들을 사용하도록 권한을 주고 회수하는 명령어
- 데이터 보호와 보안을 위해 유저/권한 관리

#### Grant
- 권한을 부여하는 DCL 명령어
- Grant 권한명 To 권한을 뷰여할 유저명;
  - Create Session : 유저가 로그인 할 수 있게 해줌
  - Create Table : 테이블을 생성할 수 있게 해줌

#### Revoke 
- 부여한 권한을 회수하는 DCL 명령어

#### Role
1. Grant 를 일일이 지정하기 번거롭기 때문에
2. Role을 생성하여 각종 권한을 부여한 후, Role 을 다른 Role이나 유저에게 부여
3. Role에 포함된 권한들이 필요한 유저에게 Role만 부여하여 빠르고 정확하게 필요한 권한을 부여할 수 있다.
4. Role을 생성하여 Role 에 권한을 부여할 때도 Grant문을 쓴다.

#### Connect, Resource Role이 보유한 권한들
1. Connect : Create Session
2. Resource : Create Cluster
3. Create Type
4. Create Table
5. Create Procedure
6. Create Trigger

### TCL (Transaction Control Language) 트랜잭션 제어어
Commit, Rollback ... <br/>
논리적인 작업의 단위를 묶어서 DML에 의해 조작된 결과를 트랜잭션(작업단위)별로 제어하는 명령어

#### Commit
- DML 구문이 성공할 때,
- 데이터에 대한 변경사항을 데이터베이스에 영구적으로 저장

#### Rollback
- DML 구문에 오류가 있을 때
- 데이터에 대한 변경사항을 모두 폐기하고 변경 전 상태로 되돌리는 명령
- 테이블 내 입력한 데이터나 수정한 데이터, 삭제한 데이터에 대하여 Commit 이전에는 변경사항을 취소할 수 있는데, 이를 Rollback 하는 것
- 데이터 변경 사항이 취소되어 데이터 이전 상태로 복구되며, 관련된 향에 대한 Locking 이 풀리고 다른 사용자들이 데이터 변경을 할 수 있게 된다.
- 커밋 되지 않은 상태의 모든 트랜잭션을 롤백하는 것이다.
- 최초의 Begin Transation 시점까지 Rollback 이 수행됨
```
Begin Transaction : 트랜잭션 실행
Commit Transaction / Rollback Transaction : 트랜잭션 종료
```

#### 트랜잭션 완료의 의미
1. 변경사항이 데이터베이스에 반영
2. 이전 데이터가 영영 사라져버린다.
3. 모든 사용자는 결과를 볼 수 있다.
4. 관련 행은 잠금이 풀리고 다른 사용자가 변경 가능하다.

#### Commit/Rollback 이전의 데이터 상태
1. 메모리 Buffer만 쌓여있으므로 데이터 변경 이전 상태로 복구 가능
2. 현재 사용자는 Select 문장으로 결과 확인 가능
3. 다른 사용자는 현재 사용자가 수행한 명령의 결과를 볼 수 없다.
4. 변경된 행은 잠금이 설정되어서 다른 사용자가 변경할 수 없다.

#### 커밋/롤백을 실행하지 않아도 자동으로 트랜잭션이 종료되는 경우
1. Create, Alter, Drop, Rename, Truncate table 등의 DDL 언어를 수행 시 전후 시점에 자동 커밋
2. DML 문장 이후 커밋 없이 DDL 문장이 실행되면 자동 커밋
3. 데이터베이스를 정상적으로 접속 종료하면 자동 커밋
4. 애플리케이션의 이상 종료로 데이터베이스와의 접속이 단절되었을 때 트랜지션이 자동 롤백

#### Savepoint
롤백할 때 트랜잭션에 포함된 전체 작업을 롤백하는 것이 아닌, 현 시점의 Savepoint 까지 트랜잭션의 일부만 롤백해준다.

#### 트랜잭션에 대한 격리성이 낮은 경우 발생하는 문제점
1. Dirty Read : 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 데이터를 읽는 것
2. Non-Repeatable Read : 한 트랜잭션 내에서 같은 쿼리르 두 번 수행했는데, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제하는 바람에 두 쿼리 결과가 다르게 나타나는 현상
3. Phantom Read : 한 트랜잭션 내에서 같은 쿼리를 2번 수행했을 때 첫번째 쿼리에서 없던 유령 레코드가 두번째 쿼리에서 나타나는 현상



## 관계형 데이터베이스
### 테이블 생성 주의사항
- 테이블명은 객체를 의미할 수 있는 적절한 이름, 단수형
- 테이블명은 다른 이름과 중복되지 않도록
- 한 테이블 내에는 컬럼명이 중복되게 지정할 수 없음
- 테이블 이름을 지정하고 각 칼럼들은 괄호로 묶어 지정
- 각 컬럼들은 콤마로 구분되고 테이블 생성문의 끝은 항상 세미콜롬으로 마친다.
- 컬럼에 대해선 다른 테이블까지 고려하여 데이터베이스 내에서 일관성있게 사용
- 컬럼 뒤에 데이터 유형은 꼭 지정되어야 한다
- 테이블명과 컬럼명은 반드시 문자로 시작해야하고 벤더별로 길이에 대한 한계가 있다.
- 벤더에서 사전에 정의한 예약어는 불가하다
- A-Z, a-z, 0-9, _, $, # 문자만 허용

### 제약조건 (Constraint)
- Check 제약 조건은 데이터베이스에서 데이터의 무결성을 유지하기 위해 테이블의 특정 컬럼에 설정하는 제약
- 기본키는 반드시 테이블 당 하나의 제약만을 정의할 수 있다.
- 고유키로 지정된 모든 컬럼들은 null 값을 가질 수 있다.
- 외래키는 테이블간의 관계를 정의하기 위해 기본키를 다른 테이블의 외래키가 참조하도록 생성



## 분산 데이터베이스
<-> 통합 데이터베이스 / GSI (Global Single Instance)
### 장점
1. 지역 자치성, 점증적 시스템 용량 확장
2. 신뢰성과 가용성
3. 효용성, 웅통성
4. 빠른 응답 속도와 통신 비용 절감
5. 시스템 규모의 적절한 조절
6. 각 지역 사용자의 요구 사용 증대

### 단점
1. 소프트웨어 개발 비용 상승
2. 오류의 잠재성 증대
3. 처리 비용 상승
4. 설계, 관리의 복잡성과 비용 상승
5. 불규칙한 응답 속도
6. 통제의 어려움
7. 데이터 무결성에 대한 위협
- 공통코드 기준정보 등 마스터 데이터를 1곳에 두고 운영하는 경우 원격자에게 접근이 빈번할수록 실시간 업무처리 성능이 나쁠 수 있으므로 분산 환경에서 복제 분산을 하는 법으로 분산 데이터베이스를 구성 가능하다.
- 백업 사이트 구성에 대해서 분산 환경으로 구성 가능


## 참조 동작 (Referential Action)
### Delete/Modify Action
1. Cascade : 참조하는 자식도 같이 삭제
2. Restrict : 자식 테이블에 PK값이 없는 경우만 삭제 허용, PK가 있으면 취소됨
3. Set Null : 마스터 삭제 시 자식 해당 필드 Null 처리
4. Set Default : 마스터 삭제 시 자식 해당 필드 Default 값으로 설정

### Insert Action
1. Automatic : 마스터 테이블에 PK가 없는 경우 마스터 PK를 생성하고 자식 입력
2. Set Null : 마스터 테이블에 PK가 없는 경우 자식 외부키를 Null 로 처리
3. Set Default : 마스터 테이블에 PK가 없는 경우 자식 외부키를 Default 로 설정
4. Dependent : 마스터 테이블에 PK가 존재할 때 자식 입력 허용



## Null
### Null 특성
- Null 은 아직 정의되지 않은 값으로 0이나 공백과는 다른다.
- 공백은 문자, 0은 숫자이다.
- 테이블을 생성할 때 Not Null 또는 PK로 정의되지 않은 모든 데이터 유형은 널값을 포함할 수 있다.
- 널 값을 포함하는 연산의 경우 결과값도 널 값이다.
`Null + 2 = Null, Null * 2 = Null, Null / 2 = Null ...`
- 결과값을 Null 이 아닌 다른 값을 얻고자 할 땐 Nvl, IsNull 함수를 사용한다.
- 널 값의 대상이 숫자인 경우 주로 0으로, 문자인 경우는 공백보단 x 같이 의미없는 문자로 바꾸는 경우가 많다.



## 함수
벤더에서 제공하는 함수인 내장 함수와 사용자가 정의할 수 있는 함수로 나눌 수 있다.
### 내장 함수
#### 단일행 함수
1. Select, Where, Order by 절에서 사용 가능
2. 각 행들에 대해 개별적으로 작용
3. 각각의 행에 대한 조작 결과를 리턴
4. 여러 인자를 입력해도 하나의 결과만 리턴
5. 여러 개의 인수를 가질 수도 있다.
6. 함수의 중첩이 가능

#### 단일행 함수의 종류
- 문자형 함수 : 문자를 입력하면 문자나 숫자를 반환
  - Lower, Upper, Substr, Length, Ltrim, Rtrim, Trim, Ascii
- 숫자형 함수 : 숫자를 입력하면 숫자를 반환
  - Abs, Mod, Round, Trunc, Sign, Chr, Ceil, Floor, Exp, Log, Ln, Power, Cos, Tan
- 날짜형 함수 : DATE 타입 값을 연산
  - Sysdate, Extract, To_number
  - 날짜형 데이터 연산
    - 날짜+숫자=날짜 : 숫자만큼 날을 날짜에 더한다.
    - 날짜-숫자=날짜 : 숫자만큼 날을 날짜에 뺀다.
    - 날짜1-날짜2=날짜수 : 다른 하나의 날짜에서 하나의 날짜를 빼면 일수가 나온다.
    - 날짜+숫자/24=날짜 : 시간을 날짜에 더한다.
    - 날짜+숫자/24/60=날짜 : 분을 날짜에 더한다.
- 변환형 함수 : 문자, 숫자, 날짜형의 값 데이터 타입을 반환
  - To_Number, To_Char, To_date
- Null 관련 함수 : Null을 처리하기 위한 함수
  - Nvl, NullIf, Coalesce
  - Nvl : Null 값을 0으로 치환
- 단일행 Case 표현의 종류
  - Case When 조건 (Then 값 혹은 SQL문) (Else 값 혹은 SQL문) End
  - Decode (조건1, 값1, 조건2, 값2, 디폴트값) : Oracle에서만 사용
- Coalesce 함수
  - Coalesce(표현식1, 표현식2, ...)
  - Null 이 아닌 최초의 표현식을 나타낸다.
  - 모든 표현식이 Null 이라면 Null을 나타낸다.

#### 단일행 함수의 특징
- Select, Where, Order by, Update Set 절에서 사용 가능
- 각 행에 대해 개별적으로 작용하여 데이터 값들을 조작하고 각각의 행에 대한 조작 결과를 반환한다.
- 여러 인자를 입력해도 하나의 결과만 리턴한다.
- 함수의 인자로 상수, 변수, 표현식이 사용 가능하고 하나의 인수 또는 여러 개의 인수를 가질 수도 있다.
- 특별한 경우가 아니라면 함수의 인자로 함수를 사용한느 함수의 중첩이 가능

#### 단일행 Null 관련 함수
1. Nvl(표현식1, 표현식2), IsNull(표현식1, 표현식2) : 표현식1의 결과값이 Null 이면 표현식2의 값을 출력 - 다만 표현식1과 표현식2의 결과 데이터 타입이 같아야 한다.
2. NullIf(표현식1, 표현식2) : 표현식1과 표현식2가 같으면 Null, 같지 않으면 표현식1을 리턴한다.
3. Coalesce(표현식1, 표현식2, ...) : 임의의 개수 표현식에서 Null 이 아닌 최초의 표현식을 나타낸다. 모든 표현식이 Null 이면 Null 을 리턴한다.

#### 다중행 함수
- 집계 함수
  - Count, Avg, Sum, Min, Max, Stddev, Variance
- 그룹 함수
  - Rollup, Cube, Grouping Sets
- 윈도우 함수



## 서브쿼리
- 하나의 SQL문 안에 포함되어 있는 또 다른 SQL문
- 서브쿼리를 메인쿼리의 컬럼을 모두 사용할 수 있지만 메인 쿼리는 서브쿼리의 컬럼을 사용할 순 없다.

### 서브쿼리 사용 시 주의
1. 서브쿼리는 괄호로 감싸서 적는다.
2. 서브쿼리는 단일행 또는 복수행 비교연산자와 함께 사용
3. 단일행 비교 연산자는 서브쿼리의 결과가 반드시 1건 이하여야하고 복수행 비교 연산자는 서브쿼리의 결과 건수와 무관하다.
  - 단일행 비교 연산자 : =, <, >, ...
  - 복수행 비교 연산자 : In, Any, ...
4. 서브쿼리에서는 Order by 절을 사용 못한다. => Order by 는 메인쿼리의 마지막 문장에 위치하므로

### 동작하는 방식에 따른 서브쿼리 분류
1. 비 연관 서브쿼리
   - 서브쿼리가 메인쿼리의 컬럼을 가지고 있지 않은 형태
   - 메인 쿼리에 값을 제공하기 위한 목적
2. 연관 서브쿼리
   - 서브쿼리가 메인 쿼리의 값을 가지고 있는 형태
   - 메인쿼리가 먼저 수행되고 읽혀진 데이터를 서브쿼리에서 조건이 맞는지 확인하고자할 때 사용

### 반환 데이터 형태에 따른 서브쿼리의 분류
1. 단일행 서브쿼리 : 실행결과가 1건 이하
2. 다중행 서브쿼리 : 실행결과가 여러 건
3. 다중 컬럼 서브쿼리 : 여러 컬럼을 반환하므로 동시에 비교 가능 - 서브쿼리와 메인쿼리의 컬럼 수와 컬럼 순서가 동일해야한다.

#### 다중행 서브쿼리
1. In : 서브쿼리의 결과에 존재하는 임의의 값과 동일한 조건 의미
2. 비교 연산자 ALL : 서브쿼리의 결과에 존재하는 모든 값을 만족하는 조건을 의미 -> 비교 연산자를 사용했으면 메인 쿼리는 서브쿼리의 모든 결과 값을 만족해야 함
3. 비교 연산자 Any : 서브쿼리의 결과에 존재하는 어느 하나의 값이라도 만족하는 조건을 의미
4. Exists : 서브쿼리의 결과를 만족하는 값이 존재하는지 여부를 확인하는 조건 -> 조건을 만족하는 1건이 있으면 중단.

### 서브쿼리가 사용 가능한 위치
1. select, from, where, having, order by
2. insert 시 values
3. update시 set

### 인라인 뷰 서브쿼리
from 절에서 사용되는 서브쿼리

### 뷰
테이블은 실제로 데이터를 가지고 있지만, 뷰는 실제 데이터를 가지고 있진 않다.

#### 뷰 장점
1. 독립성 : 테이블 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 됨
2. 편리성 : 복잡한 질의를 뷰로 생성함으로써 관련 질의를 단순하게 작성
3. 보안성 : 직원의 급여 정보 등과 같이 숨기고 싶은 정보가 존재할 때, 뷰를 생성하여 컬럼을 빼고 정보를 감출 수 있음



## Top N 쿼리
### Top N 쿼리란, 특정 순서로 데이터를 부분적으로 쿼리하는 것

#### Rownum 슈도 컬럼
SQL 처리 결과 시 각 행에 임시로 부여되는 일련번호 - Oracle 문법
- 데이터의 일부가 먼저 추출된 후 데이터에 대한 정렬 작업이 이루어진다.
- 인라인 뷰를 이용하여 집합을 정렬한 후 rownum 적용시켜 올바른 SQL문 사용해야 함

#### Top 절
결과 집합으로 출력되는 행의 수를 제한 - SQL server
  ex. Top (표현식) [Percent] [With ties]
  - 표현식 : 반환할 행 수 지정
  - Percent : 쿼리 결과 집합에서 처음 표현식%의 행만 반환됨 - 표현식 건이 아니라, 표현식의 %만큼 반환
  - With ties : Order by 절이 지정된 경우에만 사용 가능하며 마지막 행과 같은 값이 있으면 추가행이 출력되도록 지정

#### Row Limiting 절
Ansi 표준으로 어디서든 다 사용 가능
```
[Offset N {Row | Rows}]
[Fetch {First | Next} [{rowcount | percent}] {Row | Rows} {Only | With ties}]
```
- Offset N : 건너뛸 행의 개수 지정
- Fetch : 반환할 행의 개수 또는 백분율 지정
- Only : 지정된 행의 개수 또는 백분율 지정
- With ties : 마지막 행에 대한 동순위 포함해서 반환



## 계층형 질의와 Self 조인
### 계층형 질의
1. 테이블에 계층형 데이터가 존재하는 경우, 데이터를 조회하기 위해 계층형 질의 사용
2. 동일 테이블에 계층적으로 상위와 하위 데이터가 포함된 데이터를 의미

#### Oracle 계층형 질의
- Start with : 계층 구조 전개의 시작 위치를 지정하는 구문, 루트 데이터 지정
- Connect by : 다음에 전개될 자식 데이터를 지정하는 구문, 자식 데이터는 Connect by 절에 주어진 조건을 만족해야 한다.
- Prior : Conect by 절에 사용되며, 현재 읽은 칼럼을 지정
  - Prior 자식 = 부모 이면 부모 -> 자식 방향으로 순방향 전개
  - Prior 부모 = 자식 이면 자식 -> 부모 방향으로 역방향 전개
- Nocycle : 이미 나타났던 동일한 데이터가 전개 중에 다시 나타나면 오류가 발생하는데, Nocycle 을 추가하면 오류를 발생시키지 않고 사이클이 발생한 이후 데이터를 전개하지 않음
- Order siblings by : 형제 노드 사이에서 정렬을 수행

#### Oracle 계층형 질의에서 사용되는 가상 컬럼
1. Level : 루트 데이터는 1부터 하위는 +1씩 증가
2. Connect_by_Isleaf : 전개과정에서 해당 데이터가 리프 데이터면 1 아니면 0
3. Connect_by_Iscycle : 전개과정에서 자식을 갖는데 해당 데이터가 조상으로써 존재하면 1 아니면 0

### Self 조인
동일한 테이블 사이의 조인을 의미



## Pivot / Unpivot
### Pivot
행을 열로 회전

#### Pivot절 구문
1. Aggregate_function : 집계할 컬럼 지정
2. For절 : Pivot 할 컬럼을 지정
3. In절 : Pivot 할 컬럼값을 지정
```
Pivot aggregate_function(집계할 컬럼) for [Pivot할 컬럼명] In [컬럼값]
```
ex. Pivot aggregate_function(Sum(급여)) for deptno In (10, 20, 30);

### Unpivot
열을 행으로 회전

#### Unpivot절 구문
1. Unpivot column절 : Unpivot된 값이 들어갈 컬럼을 지정
2. For절 : Unpivot된 값을 설명할 값이 들어갈 컬럼을 지정
3. In절 : Unpivot할 컬럼 + 설명할 값의 리터럴 값 지정
4. Include nulls : unpivot된 열의 값이 널인 행도 결과에 포함

#### Pivot, Unpivot 을 사용할 수 없는 경우, Case 표현식 사용



## 정규 표현식
- 문자열의 규칙을 표현하는 검색 패턴
- 문자열 검색과 치환에 주로 사용

### Posix 연산자
#### 기본연산자
- . : 모든 문자와 일치
- | : or, 대체 문자를 구분
  - 먼저 들어온 문자를 리턴
  ex. Regexp_substr('aa', 'a|aa') => 'a' 리턴
#### 검색 패턴과 시작과 끝 지정
- \ : 백슬래시 다음 문자를 일반 문자로 취급 (이스케이프문자)
- ^ : 캐럿, 문자열의 시작
- $ : 문자열의 끝
#### 수량사
선행 표현식의 일치 횟수를 지정
- ? : 0회 또는 1회 일치
- '*' : 0회 또는 그 이상의 횟수로 일치
- '+' : 1회 또는 그 이상의 횟수로 일치
#### Greedy
패턴을 최대로 일치 시킴
- {m} : m회 일치
- {m,} : m회 최소 일치
- {,m} : m회 최대 일치
- {m,n} : 최소 m회, 최대 n회 일치
- () : 괄호 안 표현식을 하나의 단위로 취급
- \n : 역참조, n번때 서브 표현식과 일치, n은 1~9 사이 정수
  ex. (ab|cd)x\1 인 경우, 'abxab', 'cdxcd' ... Ok
- [char...] : 문자 리스트 중 한문자와 일치
- [...-...] : 하이픈(-)은 문자 혹은 숫자의 범위 의미
- [^char...] : 문자 리스트에 포함되지 않은 한 문자와 일치
  ex. [0-9] : 0~9까지의 숫자, [a-zA-Z] : 영대소문자
- [:digit:] : 숫자만
- [:lower:] : 소문자만
- [:upper:] : 대문자만
- [:alpha:] : 영대소문자
- [:xdigit:] : 16진수 = [0-9a-fA-F]
- [:punct:] : 구두점 기호
- [:blank:] : 공백 문자
- [:space:] : 공간 문자 -> 스페이스, 엔터, 탭

### Perl 연산자
- \d : 숫자
- \D : 숫자가 아닌 모든 문자 = [^[:digit:]]
- \w : 숫자와 영문자
- \W : 숫자와 영문자가 아닌 모든 문자 (언더바 제외) = [^[:alnum:]_]
- \s : 공백 문자
- \S : 공백 문자가 아닌 모든 문자
#### 수량사와 유사
비탐욕적으로 동작
- ?? : 0회 또는 1회 일치
- '*?' : 0회 또는 그 이상의 횟수로 일치
- '+?' : 1회 또는 그 이상의 횟수로 일치
#### Non greedy 방식
패턴을 최소로 일치시킴
- {m}? : m회 일치
- {m,}? : 최소 m회 일치
- {,m}? : 최대 m회 일치
- {m,n}? : 최소 m회 일치, 최대 n회 일치

### Regexp_like (검색문자열지정, 검색패턴지정, 일치옵션지정)
일치하면 true, 아니면 false 리턴

### Regexp_replace (검색문자열지정, 검색패턴, 변경문자열지정, 변경위치, 패턴일치횟수지정)
변경한 값을 반환

### Regexp_substr (검색문자열, 검색패턴, 검색시작위치, 패턴일치횟수, 서브표현식지정)
일치한 패턴을 반환

### Regexp_instr (검색문자열, 검색패턴, 검색시작위치, 패턴일치횟수, 반환옵션지정, 일치옵션지정, 서브표현식지정)
검색 문자열에서 일치한 패턴의 시작위치를 정수로 반환

### Regexp_count (검색문자열, 검색패턴, 시작위치, 일치옵션)
검색 문자열에서 일치한 패턴의 횟수를 반환
